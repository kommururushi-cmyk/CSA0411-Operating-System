# OS Lab Solutions in C

---

### 13. Memory Allocation Strategies (First Fit, Best Fit, Worst Fit)

```c
#include <stdio.h>

void firstFit(int blockSize[], int m, int processSize[], int n) {
    int allocation[n];
    for (int i = 0; i < n; i++)
        allocation[i] = -1;

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (blockSize[j] >= processSize[i]) {
                allocation[i] = j;
                blockSize[j] -= processSize[i];
                break;
            }
        }
    }

    printf("First Fit Allocation:\n");
    for (int i = 0; i < n; i++) {
        printf("Process %d -> ", i+1);
        if (allocation[i] != -1)
            printf("Block %d\n", allocation[i]+1);
        else
            printf("Not Allocated\n");
    }
}

void bestFit(int blockSize[], int m, int processSize[], int n) {
    int allocation[n];
    for (int i = 0; i < n; i++)
        allocation[i] = -1;

    for (int i = 0; i < n; i++) {
        int bestIdx = -1;
        for (int j = 0; j < m; j++) {
            if (blockSize[j] >= processSize[i]) {
                if (bestIdx == -1 || blockSize[j] < blockSize[bestIdx])
                    bestIdx = j;
            }
        }
        if (bestIdx != -1) {
            allocation[i] = bestIdx;
            blockSize[bestIdx] -= processSize[i];
        }
    }

    printf("Best Fit Allocation:\n");
    for (int i = 0; i < n; i++) {
        printf("Process %d -> ", i+1);
        if (allocation[i] != -1)
            printf("Block %d\n", allocation[i]+1);
        else
            printf("Not Allocated\n");
    }
}

void worstFit(int blockSize[], int m, int processSize[], int n) {
    int allocation[n];
    for (int i = 0; i < n; i++)
        allocation[i] = -1;

    for (int i = 0; i < n; i++) {
        int worstIdx = -1;
        for (int j = 0; j < m; j++) {
            if (blockSize[j] >= processSize[i]) {
                if (worstIdx == -1 || blockSize[j] > blockSize[worstIdx])
                    worstIdx = j;
            }
        }
        if (worstIdx != -1) {
            allocation[i] = worstIdx;
            blockSize[worstIdx] -= processSize[i];
        }
    }

    printf("Worst Fit Allocation:\n");
    for (int i = 0; i < n; i++) {
        printf("Process %d -> ", i+1);
        if (allocation[i] != -1)
            printf("Block %d\n", allocation[i]+1);
        else
            printf("Not Allocated\n");
    }
}

int main() {
    int blockSize[] = {100, 500, 200, 300, 600};
    int processSize[] = {212, 417, 112, 426};
    int m = sizeof(blockSize)/sizeof(blockSize[0]);
    int n = sizeof(processSize)/sizeof(processSize[0]);

    int blocks1[m], blocks2[m], blocks3[m];
    for (int i = 0; i < m; i++) {
        blocks1[i] = blocks2[i] = blocks3[i] = blockSize[i];
    }

    firstFit(blocks1, m, processSize, n);
    bestFit(blocks2, m, processSize, n);
    worstFit(blocks3, m, processSize, n);
    return 0;
}
```

---

### 14. Single-Level Directory Structure Simulation

```c
#include <stdio.h>
#include <string.h>

struct {
    char fname[20];
} dir[10];

int main() {
    int n = 0, ch;
    char f[20];
    while (1) {
        printf("\n1. Create File\n2. Delete File\n3. List Files\n4. Exit\nEnter choice: ");
        scanf("%d", &ch);
        switch (ch) {
            case 1:
                printf("Enter filename: ");
                scanf("%s", f);
                strcpy(dir[n].fname, f);
                n++;
                break;
            case 2:
                printf("Enter filename to delete: ");
                scanf("%s", f);
                for (int i = 0; i < n; i++) {
                    if (strcmp(f, dir[i].fname) == 0) {
                        strcpy(dir[i].fname, dir[n-1].fname);
                        n--;
                        printf("File deleted.\n");
                        break;
                    }
                }
                break;
            case 3:
                printf("Files: \n");
                for (int i = 0; i < n; i++)
                    printf("%s\n", dir[i].fname);
                break;
            case 4:
                return 0;
        }
    }
}
```

---

### 15. Two-Level Directory Structure Simulation

```c
#include <stdio.h>
#include <string.h>

struct {
    char dname[20];
    char fname[10][20];
    int fcount;
} dir[10];

int main() {
    int dcount = 0, ch;
    char d[20], f[20];
    while (1) {
        printf("\n1. Create Directory\n2. Create File\n3. Delete File\n4. List\n5. Exit\nEnter choice: ");
        scanf("%d", &ch);
        switch (ch) {
            case 1:
                printf("Enter directory name: ");
                scanf("%s", d);
                strcpy(dir[dcount].dname, d);
                dir[dcount].fcount = 0;
                dcount++;
                break;
            case 2:
                printf("Enter directory name: ");
                scanf("%s", d);
                for (int i = 0; i < dcount; i++) {
                    if (strcmp(d, dir[i].dname) == 0) {
                        printf("Enter filename: ");
                        scanf("%s", f);
                        strcpy(dir[i].fname[dir[i].fcount], f);
                        dir[i].fcount++;
                        break;
                    }
                }
                break;
            case 3:
                printf("Enter directory name: ");
                scanf("%s", d);
                printf("Enter filename to delete: ");
                scanf("%s", f);
                for (int i = 0; i < dcount; i++) {
                    if (strcmp(d, dir[i].dname) == 0) {
                        for (int j = 0; j < dir[i].fcount; j++) {
                            if (strcmp(f, dir[i].fname[j]) == 0) {
                                strcpy(dir[i].fname[j], dir[i].fname[dir[i].fcount-1]);
                                dir[i].fcount--;
                                printf("File deleted.\n");
                                break;
                            }
                        }
                    }
                }
                break;
            case 4:
                for (int i = 0; i < dcount; i++) {
                    printf("Directory %s:\n", dir[i].dname);
                    for (int j = 0; j < dir[i].fcount; j++)
                        printf("  %s\n", dir[i].fname[j]);
                }
                break;
            case 5:
                return 0;
        }
    }
}
```

---
